// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/weapon.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Weapon struct {
	ID            uint32           `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name          string           `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	RawDamage     float64          `protobuf:"fixed64,3,opt,name=RawDamage,proto3" json:"RawDamage,omitempty"`
	PlayerID      uint32           `protobuf:"varint,4,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	Equipped      bool             `protobuf:"varint,5,opt,name=Equipped,proto3" json:"Equipped,omitempty"`
	RarityID      uint32           `protobuf:"varint,6,opt,name=RarityID,proto3" json:"RarityID,omitempty"`
	Rarity        *Rarity          `protobuf:"bytes,7,opt,name=Rarity,proto3" json:"Rarity,omitempty"`
	EfficencyID   uint32           `protobuf:"varint,8,opt,name=EfficencyID,proto3" json:"EfficencyID,omitempty"`
	Efficency     *WeaponEfficency `protobuf:"bytes,9,opt,name=Efficency,proto3" json:"Efficency,omitempty"`
	Precision     float64          `protobuf:"fixed64,10,opt,name=Precision,proto3" json:"Precision,omitempty"`
	Durability    int32            `protobuf:"varint,11,opt,name=Durability,proto3" json:"Durability,omitempty"`
	DurabilityCap int32            `protobuf:"varint,12,opt,name=DurabilityCap,proto3" json:"DurabilityCap,omitempty"`
}

func (m *Weapon) Reset()         { *m = Weapon{} }
func (m *Weapon) String() string { return proto.CompactTextString(m) }
func (*Weapon) ProtoMessage()    {}
func (*Weapon) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{0}
}
func (m *Weapon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Weapon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Weapon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Weapon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Weapon.Merge(m, src)
}
func (m *Weapon) XXX_Size() int {
	return m.Size()
}
func (m *Weapon) XXX_DiscardUnknown() {
	xxx_messageInfo_Weapon.DiscardUnknown(m)
}

var xxx_messageInfo_Weapon proto.InternalMessageInfo

func (m *Weapon) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Weapon) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Weapon) GetRawDamage() float64 {
	if m != nil {
		return m.RawDamage
	}
	return 0
}

func (m *Weapon) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *Weapon) GetEquipped() bool {
	if m != nil {
		return m.Equipped
	}
	return false
}

func (m *Weapon) GetRarityID() uint32 {
	if m != nil {
		return m.RarityID
	}
	return 0
}

func (m *Weapon) GetRarity() *Rarity {
	if m != nil {
		return m.Rarity
	}
	return nil
}

func (m *Weapon) GetEfficencyID() uint32 {
	if m != nil {
		return m.EfficencyID
	}
	return 0
}

func (m *Weapon) GetEfficency() *WeaponEfficency {
	if m != nil {
		return m.Efficency
	}
	return nil
}

func (m *Weapon) GetPrecision() float64 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Weapon) GetDurability() int32 {
	if m != nil {
		return m.Durability
	}
	return 0
}

func (m *Weapon) GetDurabilityCap() int32 {
	if m != nil {
		return m.DurabilityCap
	}
	return 0
}

// GetWeaponByID
type GetWeaponByIDRequest struct {
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *GetWeaponByIDRequest) Reset()         { *m = GetWeaponByIDRequest{} }
func (m *GetWeaponByIDRequest) String() string { return proto.CompactTextString(m) }
func (*GetWeaponByIDRequest) ProtoMessage()    {}
func (*GetWeaponByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{1}
}
func (m *GetWeaponByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWeaponByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWeaponByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWeaponByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWeaponByIDRequest.Merge(m, src)
}
func (m *GetWeaponByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWeaponByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWeaponByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWeaponByIDRequest proto.InternalMessageInfo

func (m *GetWeaponByIDRequest) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type GetWeaponByIDResponse struct {
	Weapon *Weapon `protobuf:"bytes,1,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
}

func (m *GetWeaponByIDResponse) Reset()         { *m = GetWeaponByIDResponse{} }
func (m *GetWeaponByIDResponse) String() string { return proto.CompactTextString(m) }
func (*GetWeaponByIDResponse) ProtoMessage()    {}
func (*GetWeaponByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{2}
}
func (m *GetWeaponByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWeaponByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWeaponByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWeaponByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWeaponByIDResponse.Merge(m, src)
}
func (m *GetWeaponByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWeaponByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWeaponByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWeaponByIDResponse proto.InternalMessageInfo

func (m *GetWeaponByIDResponse) GetWeapon() *Weapon {
	if m != nil {
		return m.Weapon
	}
	return nil
}

// GetWeaponByName
type GetWeaponByNameRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *GetWeaponByNameRequest) Reset()         { *m = GetWeaponByNameRequest{} }
func (m *GetWeaponByNameRequest) String() string { return proto.CompactTextString(m) }
func (*GetWeaponByNameRequest) ProtoMessage()    {}
func (*GetWeaponByNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{3}
}
func (m *GetWeaponByNameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWeaponByNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWeaponByNameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWeaponByNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWeaponByNameRequest.Merge(m, src)
}
func (m *GetWeaponByNameRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWeaponByNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWeaponByNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWeaponByNameRequest proto.InternalMessageInfo

func (m *GetWeaponByNameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetWeaponByNameResponse struct {
	Weapon *Weapon `protobuf:"bytes,1,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
}

func (m *GetWeaponByNameResponse) Reset()         { *m = GetWeaponByNameResponse{} }
func (m *GetWeaponByNameResponse) String() string { return proto.CompactTextString(m) }
func (*GetWeaponByNameResponse) ProtoMessage()    {}
func (*GetWeaponByNameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{4}
}
func (m *GetWeaponByNameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWeaponByNameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWeaponByNameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWeaponByNameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWeaponByNameResponse.Merge(m, src)
}
func (m *GetWeaponByNameResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWeaponByNameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWeaponByNameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWeaponByNameResponse proto.InternalMessageInfo

func (m *GetWeaponByNameResponse) GetWeapon() *Weapon {
	if m != nil {
		return m.Weapon
	}
	return nil
}

// GetWeaponByPlayerAndName
type GetWeaponByPlayerAndNameRequest struct {
	Name     string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	PlayerID uint32 `protobuf:"varint,2,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetWeaponByPlayerAndNameRequest) Reset()         { *m = GetWeaponByPlayerAndNameRequest{} }
func (m *GetWeaponByPlayerAndNameRequest) String() string { return proto.CompactTextString(m) }
func (*GetWeaponByPlayerAndNameRequest) ProtoMessage()    {}
func (*GetWeaponByPlayerAndNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{5}
}
func (m *GetWeaponByPlayerAndNameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWeaponByPlayerAndNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWeaponByPlayerAndNameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWeaponByPlayerAndNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWeaponByPlayerAndNameRequest.Merge(m, src)
}
func (m *GetWeaponByPlayerAndNameRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWeaponByPlayerAndNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWeaponByPlayerAndNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWeaponByPlayerAndNameRequest proto.InternalMessageInfo

func (m *GetWeaponByPlayerAndNameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetWeaponByPlayerAndNameRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetWeaponByPlayerAndNameResponse struct {
	Weapon *Weapon `protobuf:"bytes,1,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
}

func (m *GetWeaponByPlayerAndNameResponse) Reset()         { *m = GetWeaponByPlayerAndNameResponse{} }
func (m *GetWeaponByPlayerAndNameResponse) String() string { return proto.CompactTextString(m) }
func (*GetWeaponByPlayerAndNameResponse) ProtoMessage()    {}
func (*GetWeaponByPlayerAndNameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{6}
}
func (m *GetWeaponByPlayerAndNameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWeaponByPlayerAndNameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWeaponByPlayerAndNameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWeaponByPlayerAndNameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWeaponByPlayerAndNameResponse.Merge(m, src)
}
func (m *GetWeaponByPlayerAndNameResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWeaponByPlayerAndNameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWeaponByPlayerAndNameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWeaponByPlayerAndNameResponse proto.InternalMessageInfo

func (m *GetWeaponByPlayerAndNameResponse) GetWeapon() *Weapon {
	if m != nil {
		return m.Weapon
	}
	return nil
}

// GetPlayerWeapons
type GetPlayerWeaponsRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetPlayerWeaponsRequest) Reset()         { *m = GetPlayerWeaponsRequest{} }
func (m *GetPlayerWeaponsRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerWeaponsRequest) ProtoMessage()    {}
func (*GetPlayerWeaponsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{7}
}
func (m *GetPlayerWeaponsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerWeaponsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerWeaponsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerWeaponsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerWeaponsRequest.Merge(m, src)
}
func (m *GetPlayerWeaponsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerWeaponsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerWeaponsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerWeaponsRequest proto.InternalMessageInfo

func (m *GetPlayerWeaponsRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetPlayerWeaponsResponse struct {
	Weapons []*Weapon `protobuf:"bytes,1,rep,name=Weapons,proto3" json:"Weapons,omitempty"`
}

func (m *GetPlayerWeaponsResponse) Reset()         { *m = GetPlayerWeaponsResponse{} }
func (m *GetPlayerWeaponsResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerWeaponsResponse) ProtoMessage()    {}
func (*GetPlayerWeaponsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{8}
}
func (m *GetPlayerWeaponsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerWeaponsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerWeaponsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerWeaponsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerWeaponsResponse.Merge(m, src)
}
func (m *GetPlayerWeaponsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerWeaponsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerWeaponsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerWeaponsResponse proto.InternalMessageInfo

func (m *GetPlayerWeaponsResponse) GetWeapons() []*Weapon {
	if m != nil {
		return m.Weapons
	}
	return nil
}

// GetPlayerWeaponEquipped
type GetPlayerWeaponEquippedRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetPlayerWeaponEquippedRequest) Reset()         { *m = GetPlayerWeaponEquippedRequest{} }
func (m *GetPlayerWeaponEquippedRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerWeaponEquippedRequest) ProtoMessage()    {}
func (*GetPlayerWeaponEquippedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{9}
}
func (m *GetPlayerWeaponEquippedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerWeaponEquippedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerWeaponEquippedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerWeaponEquippedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerWeaponEquippedRequest.Merge(m, src)
}
func (m *GetPlayerWeaponEquippedRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerWeaponEquippedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerWeaponEquippedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerWeaponEquippedRequest proto.InternalMessageInfo

func (m *GetPlayerWeaponEquippedRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetPlayerWeaponEquippedResponse struct {
	Weapon *Weapon `protobuf:"bytes,1,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
}

func (m *GetPlayerWeaponEquippedResponse) Reset()         { *m = GetPlayerWeaponEquippedResponse{} }
func (m *GetPlayerWeaponEquippedResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerWeaponEquippedResponse) ProtoMessage()    {}
func (*GetPlayerWeaponEquippedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{10}
}
func (m *GetPlayerWeaponEquippedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerWeaponEquippedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerWeaponEquippedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerWeaponEquippedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerWeaponEquippedResponse.Merge(m, src)
}
func (m *GetPlayerWeaponEquippedResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerWeaponEquippedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerWeaponEquippedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerWeaponEquippedResponse proto.InternalMessageInfo

func (m *GetPlayerWeaponEquippedResponse) GetWeapon() *Weapon {
	if m != nil {
		return m.Weapon
	}
	return nil
}

// EquipWeapon
type EquipWeaponRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	WeaponID uint32 `protobuf:"varint,2,opt,name=WeaponID,proto3" json:"WeaponID,omitempty"`
	Equip    bool   `protobuf:"varint,3,opt,name=Equip,proto3" json:"Equip,omitempty"`
}

func (m *EquipWeaponRequest) Reset()         { *m = EquipWeaponRequest{} }
func (m *EquipWeaponRequest) String() string { return proto.CompactTextString(m) }
func (*EquipWeaponRequest) ProtoMessage()    {}
func (*EquipWeaponRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{11}
}
func (m *EquipWeaponRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquipWeaponRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquipWeaponRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquipWeaponRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquipWeaponRequest.Merge(m, src)
}
func (m *EquipWeaponRequest) XXX_Size() int {
	return m.Size()
}
func (m *EquipWeaponRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EquipWeaponRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EquipWeaponRequest proto.InternalMessageInfo

func (m *EquipWeaponRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *EquipWeaponRequest) GetWeaponID() uint32 {
	if m != nil {
		return m.WeaponID
	}
	return 0
}

func (m *EquipWeaponRequest) GetEquip() bool {
	if m != nil {
		return m.Equip
	}
	return false
}

type EquipWeaponResponse struct {
}

func (m *EquipWeaponResponse) Reset()         { *m = EquipWeaponResponse{} }
func (m *EquipWeaponResponse) String() string { return proto.CompactTextString(m) }
func (*EquipWeaponResponse) ProtoMessage()    {}
func (*EquipWeaponResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9fb098921f1953d, []int{12}
}
func (m *EquipWeaponResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquipWeaponResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquipWeaponResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquipWeaponResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquipWeaponResponse.Merge(m, src)
}
func (m *EquipWeaponResponse) XXX_Size() int {
	return m.Size()
}
func (m *EquipWeaponResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EquipWeaponResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EquipWeaponResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Weapon)(nil), "weapon.Weapon")
	proto.RegisterType((*GetWeaponByIDRequest)(nil), "weapon.GetWeaponByIDRequest")
	proto.RegisterType((*GetWeaponByIDResponse)(nil), "weapon.GetWeaponByIDResponse")
	proto.RegisterType((*GetWeaponByNameRequest)(nil), "weapon.GetWeaponByNameRequest")
	proto.RegisterType((*GetWeaponByNameResponse)(nil), "weapon.GetWeaponByNameResponse")
	proto.RegisterType((*GetWeaponByPlayerAndNameRequest)(nil), "weapon.GetWeaponByPlayerAndNameRequest")
	proto.RegisterType((*GetWeaponByPlayerAndNameResponse)(nil), "weapon.GetWeaponByPlayerAndNameResponse")
	proto.RegisterType((*GetPlayerWeaponsRequest)(nil), "weapon.GetPlayerWeaponsRequest")
	proto.RegisterType((*GetPlayerWeaponsResponse)(nil), "weapon.GetPlayerWeaponsResponse")
	proto.RegisterType((*GetPlayerWeaponEquippedRequest)(nil), "weapon.GetPlayerWeaponEquippedRequest")
	proto.RegisterType((*GetPlayerWeaponEquippedResponse)(nil), "weapon.GetPlayerWeaponEquippedResponse")
	proto.RegisterType((*EquipWeaponRequest)(nil), "weapon.EquipWeaponRequest")
	proto.RegisterType((*EquipWeaponResponse)(nil), "weapon.EquipWeaponResponse")
}

func init() { proto.RegisterFile("proto/weapon.proto", fileDescriptor_a9fb098921f1953d) }

var fileDescriptor_a9fb098921f1953d = []byte{
	// 508 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xcd, 0xe6, 0xc3, 0x4d, 0x26, 0xb4, 0x87, 0xa5, 0x85, 0x55, 0x54, 0x2d, 0x8b, 0x85, 0x2a,
	0x1f, 0x50, 0x90, 0x40, 0x9c, 0x40, 0xaa, 0x5a, 0xb6, 0x42, 0xe6, 0x80, 0xca, 0x5e, 0x90, 0xb8,
	0xa0, 0x4d, 0xba, 0x45, 0x96, 0x5a, 0xdb, 0xb5, 0x13, 0x55, 0xf9, 0x11, 0x48, 0xfc, 0x2c, 0x8e,
	0x3d, 0x72, 0x44, 0xc9, 0x1f, 0x41, 0xde, 0x0f, 0xdb, 0x49, 0x8a, 0xd2, 0xdc, 0x32, 0xef, 0xcd,
	0xbc, 0x79, 0x33, 0xb3, 0x31, 0xe0, 0x34, 0x4b, 0x26, 0xc9, 0xab, 0x5b, 0x25, 0xd3, 0x24, 0x1e,
	0xea, 0x00, 0x7b, 0x26, 0x1a, 0x58, 0x2e, 0x93, 0x59, 0x34, 0x99, 0x19, 0x6e, 0x70, 0x58, 0xcf,
	0xff, 0xae, 0x2e, 0x2f, 0xa3, 0xb1, 0x8a, 0xc7, 0x96, 0xf5, 0x7f, 0xb6, 0xc0, 0xfb, 0xaa, 0x29,
	0xbc, 0x07, 0xcd, 0x90, 0x13, 0xc4, 0x50, 0xb0, 0x2b, 0x9a, 0x21, 0xc7, 0x18, 0xda, 0x9f, 0xe5,
	0xb5, 0x22, 0x4d, 0x86, 0x82, 0x9e, 0xd0, 0xbf, 0xf1, 0x21, 0xf4, 0x84, 0xbc, 0xe5, 0xf2, 0x5a,
	0xfe, 0x50, 0xa4, 0xc5, 0x50, 0x80, 0x44, 0x05, 0xe0, 0x01, 0x74, 0xcf, 0xaf, 0xe4, 0x4c, 0x65,
	0x21, 0x27, 0x6d, 0xad, 0x53, 0xc6, 0x05, 0x77, 0x76, 0x33, 0x8d, 0xd2, 0x54, 0x5d, 0x90, 0x0e,
	0x43, 0x41, 0x57, 0x94, 0x71, 0xc1, 0x09, 0x6d, 0x39, 0xe4, 0xc4, 0x33, 0x75, 0x2e, 0xc6, 0x47,
	0xe0, 0x99, 0xdf, 0x64, 0x87, 0xa1, 0xa0, 0xff, 0x7a, 0x6f, 0x68, 0xa7, 0x33, 0xa8, 0xb0, 0x2c,
	0x66, 0xd0, 0x3f, 0x73, 0xb3, 0x85, 0x9c, 0x74, 0xb5, 0x4c, 0x1d, 0xc2, 0xc7, 0xd0, 0x2b, 0x43,
	0xd2, 0xd3, 0x62, 0xcf, 0x87, 0x6b, 0x6b, 0x31, 0xcb, 0x28, 0x13, 0x45, 0x55, 0x53, 0x0c, 0x7f,
	0x9e, 0xa9, 0x71, 0x94, 0x47, 0x49, 0x4c, 0xc0, 0x0c, 0x5f, 0x02, 0x98, 0x02, 0xf0, 0x69, 0x26,
	0x47, 0xd1, 0x55, 0x61, 0xb6, 0xcf, 0x50, 0xd0, 0x11, 0x35, 0x04, 0xbf, 0x80, 0xdd, 0x2a, 0xfa,
	0x20, 0x53, 0xf2, 0x48, 0xa7, 0x2c, 0x83, 0xfe, 0x11, 0xec, 0x7f, 0x54, 0x13, 0x63, 0xe2, 0x74,
	0x16, 0x72, 0xa1, 0x6e, 0xa6, 0x2a, 0x9f, 0xac, 0x1e, 0xc7, 0x3f, 0x86, 0x83, 0x95, 0xbc, 0x3c,
	0x4d, 0xe2, 0x5c, 0x15, 0xfb, 0x32, 0xa8, 0x4e, 0x2e, 0xf6, 0x65, 0x5f, 0x8a, 0x41, 0x85, 0x65,
	0xfd, 0x97, 0xf0, 0xa4, 0x26, 0x50, 0x1c, 0xd7, 0xb5, 0x72, 0x77, 0x47, 0xd5, 0xdd, 0xfd, 0x13,
	0x78, 0xba, 0x96, 0xbd, 0x65, 0xc3, 0x2f, 0xf0, 0xac, 0x26, 0x61, 0xde, 0xc5, 0x49, 0x7c, 0xb1,
	0xa1, 0xf3, 0xd2, 0x9b, 0x6a, 0x2e, 0xbf, 0x29, 0xff, 0x13, 0xb0, 0xff, 0x4b, 0x6e, 0x69, 0xef,
	0xad, 0x9e, 0xd0, 0x68, 0x18, 0x28, 0x77, 0xb6, 0xea, 0x16, 0xd0, 0x8a, 0x05, 0x0e, 0x64, 0xbd,
	0xcc, 0xb6, 0x0e, 0x60, 0xc7, 0x42, 0x04, 0xb1, 0xd6, 0x3d, 0xbd, 0x1d, 0xed, 0xbf, 0x07, 0xba,
	0xa2, 0xe2, 0xfe, 0x1b, 0x0f, 0xf1, 0x10, 0xea, 0xcd, 0xde, 0x5f, 0xbd, 0xe5, 0x16, 0x46, 0x80,
	0x75, 0xad, 0x85, 0x37, 0x37, 0x2f, 0x38, 0x93, 0x5c, 0xdd, 0xc7, 0xc5, 0x78, 0x1f, 0x3a, 0x5a,
	0x4d, 0x7f, 0x29, 0xba, 0xc2, 0x04, 0xfe, 0x01, 0x3c, 0x5e, 0xea, 0x61, 0x2c, 0x9e, 0xd2, 0xdf,
	0x73, 0x8a, 0xee, 0xe6, 0x14, 0xfd, 0x9d, 0x53, 0xf4, 0x6b, 0x41, 0x1b, 0x77, 0x0b, 0xda, 0xf8,
	0xb3, 0xa0, 0x8d, 0x6f, 0xed, 0xe1, 0xbb, 0x74, 0x34, 0xf2, 0xf4, 0x07, 0xeb, 0xcd, 0xbf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x90, 0x90, 0x61, 0x78, 0x00, 0x05, 0x00, 0x00,
}

func (m *Weapon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Weapon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Weapon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DurabilityCap != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.DurabilityCap))
		i--
		dAtA[i] = 0x60
	}
	if m.Durability != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.Durability))
		i--
		dAtA[i] = 0x58
	}
	if m.Precision != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Precision))))
		i--
		dAtA[i] = 0x51
	}
	if m.Efficency != nil {
		{
			size, err := m.Efficency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeapon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.EfficencyID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.EfficencyID))
		i--
		dAtA[i] = 0x40
	}
	if m.Rarity != nil {
		{
			size, err := m.Rarity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeapon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RarityID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.RarityID))
		i--
		dAtA[i] = 0x30
	}
	if m.Equipped {
		i--
		if m.Equipped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PlayerID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x20
	}
	if m.RawDamage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RawDamage))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWeapon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWeaponByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWeaponByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWeaponByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWeaponByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWeaponByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWeaponByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weapon != nil {
		{
			size, err := m.Weapon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeapon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWeaponByNameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWeaponByNameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWeaponByNameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWeapon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWeaponByNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWeaponByNameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWeaponByNameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weapon != nil {
		{
			size, err := m.Weapon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeapon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWeaponByPlayerAndNameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWeaponByPlayerAndNameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWeaponByPlayerAndNameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWeapon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWeaponByPlayerAndNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWeaponByPlayerAndNameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWeaponByPlayerAndNameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weapon != nil {
		{
			size, err := m.Weapon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeapon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerWeaponsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerWeaponsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerWeaponsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerWeaponsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerWeaponsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerWeaponsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weapons) > 0 {
		for iNdEx := len(m.Weapons) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Weapons[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWeapon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerWeaponEquippedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerWeaponEquippedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerWeaponEquippedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerWeaponEquippedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerWeaponEquippedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerWeaponEquippedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weapon != nil {
		{
			size, err := m.Weapon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWeapon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EquipWeaponRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipWeaponRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EquipWeaponRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Equip {
		i--
		if m.Equip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.WeaponID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.WeaponID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != 0 {
		i = encodeVarintWeapon(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EquipWeaponResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipWeaponResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EquipWeaponResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintWeapon(dAtA []byte, offset int, v uint64) int {
	offset -= sovWeapon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Weapon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovWeapon(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWeapon(uint64(l))
	}
	if m.RawDamage != 0 {
		n += 9
	}
	if m.PlayerID != 0 {
		n += 1 + sovWeapon(uint64(m.PlayerID))
	}
	if m.Equipped {
		n += 2
	}
	if m.RarityID != 0 {
		n += 1 + sovWeapon(uint64(m.RarityID))
	}
	if m.Rarity != nil {
		l = m.Rarity.Size()
		n += 1 + l + sovWeapon(uint64(l))
	}
	if m.EfficencyID != 0 {
		n += 1 + sovWeapon(uint64(m.EfficencyID))
	}
	if m.Efficency != nil {
		l = m.Efficency.Size()
		n += 1 + l + sovWeapon(uint64(l))
	}
	if m.Precision != 0 {
		n += 9
	}
	if m.Durability != 0 {
		n += 1 + sovWeapon(uint64(m.Durability))
	}
	if m.DurabilityCap != 0 {
		n += 1 + sovWeapon(uint64(m.DurabilityCap))
	}
	return n
}

func (m *GetWeaponByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovWeapon(uint64(m.ID))
	}
	return n
}

func (m *GetWeaponByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Weapon != nil {
		l = m.Weapon.Size()
		n += 1 + l + sovWeapon(uint64(l))
	}
	return n
}

func (m *GetWeaponByNameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWeapon(uint64(l))
	}
	return n
}

func (m *GetWeaponByNameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Weapon != nil {
		l = m.Weapon.Size()
		n += 1 + l + sovWeapon(uint64(l))
	}
	return n
}

func (m *GetWeaponByPlayerAndNameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWeapon(uint64(l))
	}
	if m.PlayerID != 0 {
		n += 1 + sovWeapon(uint64(m.PlayerID))
	}
	return n
}

func (m *GetWeaponByPlayerAndNameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Weapon != nil {
		l = m.Weapon.Size()
		n += 1 + l + sovWeapon(uint64(l))
	}
	return n
}

func (m *GetPlayerWeaponsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovWeapon(uint64(m.PlayerID))
	}
	return n
}

func (m *GetPlayerWeaponsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Weapons) > 0 {
		for _, e := range m.Weapons {
			l = e.Size()
			n += 1 + l + sovWeapon(uint64(l))
		}
	}
	return n
}

func (m *GetPlayerWeaponEquippedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovWeapon(uint64(m.PlayerID))
	}
	return n
}

func (m *GetPlayerWeaponEquippedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Weapon != nil {
		l = m.Weapon.Size()
		n += 1 + l + sovWeapon(uint64(l))
	}
	return n
}

func (m *EquipWeaponRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovWeapon(uint64(m.PlayerID))
	}
	if m.WeaponID != 0 {
		n += 1 + sovWeapon(uint64(m.WeaponID))
	}
	if m.Equip {
		n += 2
	}
	return n
}

func (m *EquipWeaponResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovWeapon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWeapon(x uint64) (n int) {
	return sovWeapon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Weapon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Weapon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Weapon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawDamage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RawDamage = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equipped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Equipped = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RarityID", wireType)
			}
			m.RarityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RarityID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rarity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rarity == nil {
				m.Rarity = &Rarity{}
			}
			if err := m.Rarity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EfficencyID", wireType)
			}
			m.EfficencyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EfficencyID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Efficency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Efficency == nil {
				m.Efficency = &WeaponEfficency{}
			}
			if err := m.Efficency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Precision = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durability", wireType)
			}
			m.Durability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Durability |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurabilityCap", wireType)
			}
			m.DurabilityCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurabilityCap |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWeaponByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWeaponByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWeaponByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWeaponByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWeaponByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWeaponByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weapon == nil {
				m.Weapon = &Weapon{}
			}
			if err := m.Weapon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWeaponByNameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWeaponByNameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWeaponByNameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWeaponByNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWeaponByNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWeaponByNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weapon == nil {
				m.Weapon = &Weapon{}
			}
			if err := m.Weapon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWeaponByPlayerAndNameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWeaponByPlayerAndNameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWeaponByPlayerAndNameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWeaponByPlayerAndNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWeaponByPlayerAndNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWeaponByPlayerAndNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weapon == nil {
				m.Weapon = &Weapon{}
			}
			if err := m.Weapon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerWeaponsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerWeaponsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerWeaponsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerWeaponsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerWeaponsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerWeaponsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weapons = append(m.Weapons, &Weapon{})
			if err := m.Weapons[len(m.Weapons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerWeaponEquippedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerWeaponEquippedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerWeaponEquippedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerWeaponEquippedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerWeaponEquippedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerWeaponEquippedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeapon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWeapon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weapon == nil {
				m.Weapon = &Weapon{}
			}
			if err := m.Weapon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipWeaponRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipWeaponRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipWeaponRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponID", wireType)
			}
			m.WeaponID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Equip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipWeaponResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipWeaponResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipWeaponResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWeapon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWeapon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWeapon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWeapon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeapon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWeapon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWeapon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWeapon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWeapon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWeapon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWeapon = fmt.Errorf("proto: unexpected end of group")
)
