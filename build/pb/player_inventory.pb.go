// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/player_inventory.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PlayerInventory struct {
	ID                uint32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	PlayerID          uint32    `protobuf:"varint,2,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	Quantity          int32     `protobuf:"varint,3,opt,name=Quantity,proto3" json:"Quantity,omitempty"`
	EntityID          uint32    `protobuf:"varint,4,opt,name=EntityID,proto3" json:"EntityID,omitempty"`
	TransactionTypeID uint32    `protobuf:"varint,5,opt,name=TransactionTypeID,proto3" json:"TransactionTypeID,omitempty"`
	Resource          *Resource `protobuf:"bytes,6,opt,name=Resource,proto3" json:"Resource,omitempty"`
	Item              *Item     `protobuf:"bytes,7,opt,name=Item,proto3" json:"Item,omitempty"`
}

func (m *PlayerInventory) Reset()         { *m = PlayerInventory{} }
func (m *PlayerInventory) String() string { return proto.CompactTextString(m) }
func (*PlayerInventory) ProtoMessage()    {}
func (*PlayerInventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{0}
}
func (m *PlayerInventory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerInventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerInventory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerInventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerInventory.Merge(m, src)
}
func (m *PlayerInventory) XXX_Size() int {
	return m.Size()
}
func (m *PlayerInventory) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerInventory.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerInventory proto.InternalMessageInfo

func (m *PlayerInventory) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PlayerInventory) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *PlayerInventory) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlayerInventory) GetEntityID() uint32 {
	if m != nil {
		return m.EntityID
	}
	return 0
}

func (m *PlayerInventory) GetTransactionTypeID() uint32 {
	if m != nil {
		return m.TransactionTypeID
	}
	return 0
}

func (m *PlayerInventory) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *PlayerInventory) GetItem() *Item {
	if m != nil {
		return m.Item
	}
	return nil
}

// GetPlayerResources
type GetPlayerResourcesRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetPlayerResourcesRequest) Reset()         { *m = GetPlayerResourcesRequest{} }
func (m *GetPlayerResourcesRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerResourcesRequest) ProtoMessage()    {}
func (*GetPlayerResourcesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{1}
}
func (m *GetPlayerResourcesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerResourcesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerResourcesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerResourcesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerResourcesRequest.Merge(m, src)
}
func (m *GetPlayerResourcesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerResourcesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerResourcesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerResourcesRequest proto.InternalMessageInfo

func (m *GetPlayerResourcesRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetPlayerResourcesResponse struct {
	PlayerInventory []*PlayerInventory `protobuf:"bytes,1,rep,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerResourcesResponse) Reset()         { *m = GetPlayerResourcesResponse{} }
func (m *GetPlayerResourcesResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerResourcesResponse) ProtoMessage()    {}
func (*GetPlayerResourcesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{2}
}
func (m *GetPlayerResourcesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerResourcesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerResourcesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerResourcesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerResourcesResponse.Merge(m, src)
}
func (m *GetPlayerResourcesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerResourcesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerResourcesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerResourcesResponse proto.InternalMessageInfo

func (m *GetPlayerResourcesResponse) GetPlayerInventory() []*PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// GetPlayerResourcesByCategoryID
type GetPlayerResourcesByCategoryIDRequest struct {
	PlayerID           uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	ResourceCategoryID uint32 `protobuf:"varint,2,opt,name=ResourceCategoryID,proto3" json:"ResourceCategoryID,omitempty"`
}

func (m *GetPlayerResourcesByCategoryIDRequest) Reset()         { *m = GetPlayerResourcesByCategoryIDRequest{} }
func (m *GetPlayerResourcesByCategoryIDRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerResourcesByCategoryIDRequest) ProtoMessage()    {}
func (*GetPlayerResourcesByCategoryIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{3}
}
func (m *GetPlayerResourcesByCategoryIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerResourcesByCategoryIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerResourcesByCategoryIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerResourcesByCategoryIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerResourcesByCategoryIDRequest.Merge(m, src)
}
func (m *GetPlayerResourcesByCategoryIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerResourcesByCategoryIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerResourcesByCategoryIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerResourcesByCategoryIDRequest proto.InternalMessageInfo

func (m *GetPlayerResourcesByCategoryIDRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *GetPlayerResourcesByCategoryIDRequest) GetResourceCategoryID() uint32 {
	if m != nil {
		return m.ResourceCategoryID
	}
	return 0
}

type GetPlayerResourcesByCategoryIDResponse struct {
	PlayerInventory []*PlayerInventory `protobuf:"bytes,1,rep,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerResourcesByCategoryIDResponse) Reset() {
	*m = GetPlayerResourcesByCategoryIDResponse{}
}
func (m *GetPlayerResourcesByCategoryIDResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerResourcesByCategoryIDResponse) ProtoMessage()    {}
func (*GetPlayerResourcesByCategoryIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{4}
}
func (m *GetPlayerResourcesByCategoryIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerResourcesByCategoryIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerResourcesByCategoryIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerResourcesByCategoryIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerResourcesByCategoryIDResponse.Merge(m, src)
}
func (m *GetPlayerResourcesByCategoryIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerResourcesByCategoryIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerResourcesByCategoryIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerResourcesByCategoryIDResponse proto.InternalMessageInfo

func (m *GetPlayerResourcesByCategoryIDResponse) GetPlayerInventory() []*PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// GetPlayerItems
type GetPlayerItemsRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetPlayerItemsRequest) Reset()         { *m = GetPlayerItemsRequest{} }
func (m *GetPlayerItemsRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerItemsRequest) ProtoMessage()    {}
func (*GetPlayerItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{5}
}
func (m *GetPlayerItemsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerItemsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerItemsRequest.Merge(m, src)
}
func (m *GetPlayerItemsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerItemsRequest proto.InternalMessageInfo

func (m *GetPlayerItemsRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetPlayerItemsResponse struct {
	PlayerInventory []*PlayerInventory `protobuf:"bytes,1,rep,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerItemsResponse) Reset()         { *m = GetPlayerItemsResponse{} }
func (m *GetPlayerItemsResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerItemsResponse) ProtoMessage()    {}
func (*GetPlayerItemsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{6}
}
func (m *GetPlayerItemsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerItemsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerItemsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerItemsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerItemsResponse.Merge(m, src)
}
func (m *GetPlayerItemsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerItemsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerItemsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerItemsResponse proto.InternalMessageInfo

func (m *GetPlayerItemsResponse) GetPlayerInventory() []*PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// GetPlayerAmulets
type GetPlayerAmuletsRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetPlayerAmuletsRequest) Reset()         { *m = GetPlayerAmuletsRequest{} }
func (m *GetPlayerAmuletsRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerAmuletsRequest) ProtoMessage()    {}
func (*GetPlayerAmuletsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{7}
}
func (m *GetPlayerAmuletsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerAmuletsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerAmuletsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerAmuletsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerAmuletsRequest.Merge(m, src)
}
func (m *GetPlayerAmuletsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerAmuletsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerAmuletsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerAmuletsRequest proto.InternalMessageInfo

func (m *GetPlayerAmuletsRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetPlayerAmuletsResponse struct {
	PlayerInventory *PlayerInventory `protobuf:"bytes,1,opt,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerAmuletsResponse) Reset()         { *m = GetPlayerAmuletsResponse{} }
func (m *GetPlayerAmuletsResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerAmuletsResponse) ProtoMessage()    {}
func (*GetPlayerAmuletsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{8}
}
func (m *GetPlayerAmuletsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerAmuletsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerAmuletsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerAmuletsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerAmuletsResponse.Merge(m, src)
}
func (m *GetPlayerAmuletsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerAmuletsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerAmuletsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerAmuletsResponse proto.InternalMessageInfo

func (m *GetPlayerAmuletsResponse) GetPlayerInventory() *PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// GetPlayerItemByID
type GetPlayerItemByIDRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	ItemID   uint32 `protobuf:"varint,2,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
}

func (m *GetPlayerItemByIDRequest) Reset()         { *m = GetPlayerItemByIDRequest{} }
func (m *GetPlayerItemByIDRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerItemByIDRequest) ProtoMessage()    {}
func (*GetPlayerItemByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{9}
}
func (m *GetPlayerItemByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerItemByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerItemByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerItemByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerItemByIDRequest.Merge(m, src)
}
func (m *GetPlayerItemByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerItemByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerItemByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerItemByIDRequest proto.InternalMessageInfo

func (m *GetPlayerItemByIDRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *GetPlayerItemByIDRequest) GetItemID() uint32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

type GetPlayerItemByIDResponse struct {
	PlayerInventory *PlayerInventory `protobuf:"bytes,1,opt,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerItemByIDResponse) Reset()         { *m = GetPlayerItemByIDResponse{} }
func (m *GetPlayerItemByIDResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerItemByIDResponse) ProtoMessage()    {}
func (*GetPlayerItemByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{10}
}
func (m *GetPlayerItemByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerItemByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerItemByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerItemByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerItemByIDResponse.Merge(m, src)
}
func (m *GetPlayerItemByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerItemByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerItemByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerItemByIDResponse proto.InternalMessageInfo

func (m *GetPlayerItemByIDResponse) GetPlayerInventory() *PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// GetPlayerResourceByID
type GetPlayerResourceByIDRequest struct {
	PlayerID   uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	ResourceID uint32 `protobuf:"varint,2,opt,name=ResourceID,proto3" json:"ResourceID,omitempty"`
}

func (m *GetPlayerResourceByIDRequest) Reset()         { *m = GetPlayerResourceByIDRequest{} }
func (m *GetPlayerResourceByIDRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerResourceByIDRequest) ProtoMessage()    {}
func (*GetPlayerResourceByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{11}
}
func (m *GetPlayerResourceByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerResourceByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerResourceByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerResourceByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerResourceByIDRequest.Merge(m, src)
}
func (m *GetPlayerResourceByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerResourceByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerResourceByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerResourceByIDRequest proto.InternalMessageInfo

func (m *GetPlayerResourceByIDRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *GetPlayerResourceByIDRequest) GetResourceID() uint32 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

type GetPlayerResourceByIDResponse struct {
	PlayerInventory *PlayerInventory `protobuf:"bytes,1,opt,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerResourceByIDResponse) Reset()         { *m = GetPlayerResourceByIDResponse{} }
func (m *GetPlayerResourceByIDResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerResourceByIDResponse) ProtoMessage()    {}
func (*GetPlayerResourceByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{12}
}
func (m *GetPlayerResourceByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerResourceByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerResourceByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerResourceByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerResourceByIDResponse.Merge(m, src)
}
func (m *GetPlayerResourceByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerResourceByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerResourceByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerResourceByIDResponse proto.InternalMessageInfo

func (m *GetPlayerResourceByIDResponse) GetPlayerInventory() *PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// GetPlayerPacks
type GetPlayerPacksRequest struct {
	PlayerID uint32 `protobuf:"varint,1,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
}

func (m *GetPlayerPacksRequest) Reset()         { *m = GetPlayerPacksRequest{} }
func (m *GetPlayerPacksRequest) String() string { return proto.CompactTextString(m) }
func (*GetPlayerPacksRequest) ProtoMessage()    {}
func (*GetPlayerPacksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{13}
}
func (m *GetPlayerPacksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerPacksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerPacksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerPacksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerPacksRequest.Merge(m, src)
}
func (m *GetPlayerPacksRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerPacksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerPacksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerPacksRequest proto.InternalMessageInfo

func (m *GetPlayerPacksRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

type GetPlayerPacksResponse struct {
	PlayerInventory []*PlayerInventory `protobuf:"bytes,1,rep,name=PlayerInventory,proto3" json:"PlayerInventory,omitempty"`
}

func (m *GetPlayerPacksResponse) Reset()         { *m = GetPlayerPacksResponse{} }
func (m *GetPlayerPacksResponse) String() string { return proto.CompactTextString(m) }
func (*GetPlayerPacksResponse) ProtoMessage()    {}
func (*GetPlayerPacksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{14}
}
func (m *GetPlayerPacksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerPacksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerPacksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerPacksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerPacksResponse.Merge(m, src)
}
func (m *GetPlayerPacksResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerPacksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerPacksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerPacksResponse proto.InternalMessageInfo

func (m *GetPlayerPacksResponse) GetPlayerInventory() []*PlayerInventory {
	if m != nil {
		return m.PlayerInventory
	}
	return nil
}

// DepositResources
type DepositResourceRequest struct {
	ResourceID uint32 `protobuf:"varint,1,opt,name=ResourceID,proto3" json:"ResourceID,omitempty"`
	PlayerID   uint32 `protobuf:"varint,2,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	Quantity   int32  `protobuf:"varint,3,opt,name=Quantity,proto3" json:"Quantity,omitempty"`
}

func (m *DepositResourceRequest) Reset()         { *m = DepositResourceRequest{} }
func (m *DepositResourceRequest) String() string { return proto.CompactTextString(m) }
func (*DepositResourceRequest) ProtoMessage()    {}
func (*DepositResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{15}
}
func (m *DepositResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositResourceRequest.Merge(m, src)
}
func (m *DepositResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DepositResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DepositResourceRequest proto.InternalMessageInfo

func (m *DepositResourceRequest) GetResourceID() uint32 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

func (m *DepositResourceRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *DepositResourceRequest) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type DepositResourceResponse struct {
}

func (m *DepositResourceResponse) Reset()         { *m = DepositResourceResponse{} }
func (m *DepositResourceResponse) String() string { return proto.CompactTextString(m) }
func (*DepositResourceResponse) ProtoMessage()    {}
func (*DepositResourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{16}
}
func (m *DepositResourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositResourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositResourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositResourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositResourceResponse.Merge(m, src)
}
func (m *DepositResourceResponse) XXX_Size() int {
	return m.Size()
}
func (m *DepositResourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositResourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DepositResourceResponse proto.InternalMessageInfo

// WithdrawResources
type WithdrawResourceRequest struct {
	ResourceID uint32 `protobuf:"varint,1,opt,name=ResourceID,proto3" json:"ResourceID,omitempty"`
	PlayerID   uint32 `protobuf:"varint,2,opt,name=PlayerID,proto3" json:"PlayerID,omitempty"`
	Quantity   int32  `protobuf:"varint,3,opt,name=Quantity,proto3" json:"Quantity,omitempty"`
}

func (m *WithdrawResourceRequest) Reset()         { *m = WithdrawResourceRequest{} }
func (m *WithdrawResourceRequest) String() string { return proto.CompactTextString(m) }
func (*WithdrawResourceRequest) ProtoMessage()    {}
func (*WithdrawResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{17}
}
func (m *WithdrawResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawResourceRequest.Merge(m, src)
}
func (m *WithdrawResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawResourceRequest proto.InternalMessageInfo

func (m *WithdrawResourceRequest) GetResourceID() uint32 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

func (m *WithdrawResourceRequest) GetPlayerID() uint32 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *WithdrawResourceRequest) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type WithdrawResourceResponse struct {
}

func (m *WithdrawResourceResponse) Reset()         { *m = WithdrawResourceResponse{} }
func (m *WithdrawResourceResponse) String() string { return proto.CompactTextString(m) }
func (*WithdrawResourceResponse) ProtoMessage()    {}
func (*WithdrawResourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17e463cfd00f9e1f, []int{18}
}
func (m *WithdrawResourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawResourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawResourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawResourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawResourceResponse.Merge(m, src)
}
func (m *WithdrawResourceResponse) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawResourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawResourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawResourceResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*PlayerInventory)(nil), "player_inventory.PlayerInventory")
	proto.RegisterType((*GetPlayerResourcesRequest)(nil), "player_inventory.GetPlayerResourcesRequest")
	proto.RegisterType((*GetPlayerResourcesResponse)(nil), "player_inventory.GetPlayerResourcesResponse")
	proto.RegisterType((*GetPlayerResourcesByCategoryIDRequest)(nil), "player_inventory.GetPlayerResourcesByCategoryIDRequest")
	proto.RegisterType((*GetPlayerResourcesByCategoryIDResponse)(nil), "player_inventory.GetPlayerResourcesByCategoryIDResponse")
	proto.RegisterType((*GetPlayerItemsRequest)(nil), "player_inventory.GetPlayerItemsRequest")
	proto.RegisterType((*GetPlayerItemsResponse)(nil), "player_inventory.GetPlayerItemsResponse")
	proto.RegisterType((*GetPlayerAmuletsRequest)(nil), "player_inventory.GetPlayerAmuletsRequest")
	proto.RegisterType((*GetPlayerAmuletsResponse)(nil), "player_inventory.GetPlayerAmuletsResponse")
	proto.RegisterType((*GetPlayerItemByIDRequest)(nil), "player_inventory.GetPlayerItemByIDRequest")
	proto.RegisterType((*GetPlayerItemByIDResponse)(nil), "player_inventory.GetPlayerItemByIDResponse")
	proto.RegisterType((*GetPlayerResourceByIDRequest)(nil), "player_inventory.GetPlayerResourceByIDRequest")
	proto.RegisterType((*GetPlayerResourceByIDResponse)(nil), "player_inventory.GetPlayerResourceByIDResponse")
	proto.RegisterType((*GetPlayerPacksRequest)(nil), "player_inventory.GetPlayerPacksRequest")
	proto.RegisterType((*GetPlayerPacksResponse)(nil), "player_inventory.GetPlayerPacksResponse")
	proto.RegisterType((*DepositResourceRequest)(nil), "player_inventory.DepositResourceRequest")
	proto.RegisterType((*DepositResourceResponse)(nil), "player_inventory.DepositResourceResponse")
	proto.RegisterType((*WithdrawResourceRequest)(nil), "player_inventory.WithdrawResourceRequest")
	proto.RegisterType((*WithdrawResourceResponse)(nil), "player_inventory.WithdrawResourceResponse")
}

func init() { proto.RegisterFile("proto/player_inventory.proto", fileDescriptor_17e463cfd00f9e1f) }

var fileDescriptor_17e463cfd00f9e1f = []byte{
	// 512 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xd1, 0x6a, 0xd4, 0x40,
	0x14, 0xdd, 0xd9, 0x6e, 0xd7, 0x72, 0x8b, 0x5a, 0x07, 0xdd, 0x9d, 0x86, 0x3a, 0xac, 0x03, 0xca,
	0x3e, 0x48, 0x84, 0x16, 0xf1, 0xc1, 0x27, 0xd7, 0x88, 0x04, 0x41, 0x6a, 0x28, 0x08, 0x7d, 0x91,
	0x74, 0x1d, 0xda, 0xe0, 0x6e, 0x92, 0x26, 0x13, 0x25, 0x7f, 0xe1, 0x67, 0xf9, 0xd8, 0x47, 0x1f,
	0x65, 0xf7, 0x13, 0xfc, 0x01, 0xc9, 0x4c, 0x32, 0xdd, 0xcd, 0x54, 0x8d, 0x85, 0xf8, 0xb6, 0x73,
	0xee, 0x39, 0xb9, 0xe7, 0xdc, 0xb9, 0x9b, 0xc0, 0x5e, 0x9c, 0x44, 0x22, 0x7a, 0x12, 0xcf, 0xfc,
	0x9c, 0x27, 0x1f, 0x82, 0xf0, 0x33, 0x0f, 0x45, 0x94, 0xe4, 0xb6, 0x84, 0xf1, 0x4e, 0x1d, 0xb7,
	0x76, 0x14, 0x3f, 0x10, 0x7c, 0xae, 0x38, 0xd6, 0x5d, 0x85, 0x24, 0x3c, 0x8d, 0xb2, 0x64, 0xca,
	0x15, 0xca, 0x7e, 0x22, 0xb8, 0x7d, 0x28, 0xc5, 0x6e, 0xa5, 0xc5, 0xb7, 0xa0, 0xeb, 0x3a, 0x04,
	0x8d, 0xd0, 0xf8, 0xa6, 0xd7, 0x75, 0x1d, 0x6c, 0xc1, 0x56, 0x49, 0x71, 0x48, 0x57, 0xa2, 0xfa,
	0x5c, 0xd4, 0xde, 0x65, 0x7e, 0x28, 0x02, 0x91, 0x93, 0x8d, 0x11, 0x1a, 0x6f, 0x7a, 0xfa, 0x5c,
	0xd4, 0x5e, 0xc9, 0x5f, 0xae, 0x43, 0x7a, 0x4a, 0x57, 0x9d, 0xf1, 0x63, 0xb8, 0x73, 0x94, 0xf8,
	0x61, 0xea, 0x4f, 0x45, 0x10, 0x85, 0x47, 0x79, 0xcc, 0x5d, 0x87, 0x6c, 0x4a, 0x92, 0x59, 0xc0,
	0x36, 0x6c, 0x79, 0xa5, 0x6f, 0xd2, 0x1f, 0xa1, 0xf1, 0xf6, 0x3e, 0xb6, 0x75, 0x90, 0xaa, 0xe2,
	0x69, 0x0e, 0xa6, 0xd0, 0x73, 0x05, 0x9f, 0x93, 0x1b, 0x92, 0x0b, 0xb6, 0x1c, 0x43, 0x81, 0x78,
	0x12, 0x67, 0xcf, 0x60, 0xf7, 0x35, 0x17, 0x2a, 0x44, 0x25, 0x4a, 0x3d, 0x7e, 0x9e, 0xf1, 0x54,
	0xac, 0xc5, 0x45, 0xeb, 0x71, 0x59, 0x00, 0xd6, 0x55, 0xc2, 0x34, 0x8e, 0xc2, 0x94, 0xe3, 0x37,
	0xc6, 0x2c, 0x09, 0x1a, 0x6d, 0x8c, 0xb7, 0xf7, 0x1f, 0xd8, 0xc6, 0xc5, 0xd5, 0x88, 0x5e, 0x5d,
	0xc9, 0x52, 0x78, 0x68, 0xb6, 0x9a, 0xe4, 0x2f, 0x7d, 0xc1, 0x4f, 0xa3, 0x24, 0x77, 0x9d, 0x06,
	0x7e, 0xb1, 0x0d, 0xb8, 0xd2, 0x5e, 0x0a, 0xcb, 0x4b, 0xbc, 0xa2, 0xc2, 0x32, 0x78, 0xf4, 0xb7,
	0xa6, 0x6d, 0x64, 0x3d, 0x80, 0x7b, 0xba, 0x6d, 0x71, 0x41, 0x8d, 0xee, 0x82, 0xc3, 0xa0, 0x2e,
	0x6a, 0xc3, 0xdb, 0x53, 0x18, 0xea, 0x36, 0x2f, 0xe6, 0xd9, 0x8c, 0x8b, 0x46, 0xee, 0x4e, 0x81,
	0x98, 0xb2, 0x3f, 0xf9, 0x43, 0xd7, 0xf4, 0xf7, 0x76, 0xa5, 0x51, 0x31, 0x86, 0x49, 0xc3, 0xd5,
	0x18, 0x40, 0xbf, 0xa0, 0xeb, 0x75, 0x28, 0x4f, 0xec, 0x6c, 0xe5, 0xbf, 0x71, 0xf9, 0xbc, 0x36,
	0x9c, 0x1f, 0xc3, 0x9e, 0xb1, 0x6c, 0x4d, 0xdd, 0x53, 0x80, 0x4a, 0xa2, 0x13, 0xac, 0x20, 0x6c,
	0x06, 0xf7, 0x7f, 0xf3, 0xec, 0x36, 0x92, 0xac, 0xee, 0xef, 0xa1, 0x3f, 0xfd, 0xf4, 0xcf, 0xfb,
	0x5b, 0x8a, 0xda, 0xd8, 0xdf, 0x18, 0x06, 0x0e, 0x8f, 0xa3, 0x34, 0x10, 0xfa, 0x45, 0x59, 0x9a,
	0x5b, 0x9f, 0x21, 0xaa, 0xcf, 0xf0, 0xba, 0xef, 0x7d, 0xb6, 0x0b, 0x43, 0xa3, 0xa3, 0x4a, 0xc6,
	0xce, 0x61, 0xf8, 0x3e, 0x10, 0x67, 0x1f, 0x13, 0xff, 0xcb, 0xff, 0x72, 0x63, 0x01, 0x31, 0x5b,
	0x2a, 0x3b, 0x13, 0xfa, 0x6d, 0x41, 0xd1, 0xc5, 0x82, 0xa2, 0x1f, 0x0b, 0x8a, 0xbe, 0x2e, 0x69,
	0xe7, 0x62, 0x49, 0x3b, 0xdf, 0x97, 0xb4, 0x73, 0xdc, 0xb3, 0x9f, 0xc7, 0x27, 0x27, 0x7d, 0xf9,
	0x91, 0x3c, 0xf8, 0x15, 0x00, 0x00, 0xff, 0xff, 0x1b, 0x11, 0x65, 0x17, 0x7e, 0x07, 0x00, 0x00,
}

func (m *PlayerInventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerInventory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerInventory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TransactionTypeID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.TransactionTypeID))
		i--
		dAtA[i] = 0x28
	}
	if m.EntityID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.EntityID))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantity != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerResourcesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerResourcesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerResourcesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerResourcesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerResourcesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerResourcesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for iNdEx := len(m.PlayerInventory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayerInventory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerResourcesByCategoryIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerResourcesByCategoryIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerResourcesByCategoryIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceCategoryID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.ResourceCategoryID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerResourcesByCategoryIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerResourcesByCategoryIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerResourcesByCategoryIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for iNdEx := len(m.PlayerInventory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayerInventory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerItemsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerItemsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerItemsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerItemsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerItemsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerItemsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for iNdEx := len(m.PlayerInventory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayerInventory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerAmuletsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerAmuletsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerAmuletsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerAmuletsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerAmuletsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerAmuletsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerInventory != nil {
		{
			size, err := m.PlayerInventory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerItemByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerItemByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerItemByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.ItemID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerItemByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerItemByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerItemByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerInventory != nil {
		{
			size, err := m.PlayerInventory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerResourceByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerResourceByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerResourceByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.ResourceID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerResourceByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerResourceByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerResourceByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerInventory != nil {
		{
			size, err := m.PlayerInventory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerPacksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerPacksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerPacksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPlayerPacksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerPacksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerPacksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for iNdEx := len(m.PlayerInventory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayerInventory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayerInventory(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DepositResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantity != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x10
	}
	if m.ResourceID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.ResourceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DepositResourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositResourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositResourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *WithdrawResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantity != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x10
	}
	if m.ResourceID != 0 {
		i = encodeVarintPlayerInventory(dAtA, i, uint64(m.ResourceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawResourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawResourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawResourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPlayerInventory(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlayerInventory(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PlayerInventory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.ID))
	}
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	if m.Quantity != 0 {
		n += 1 + sovPlayerInventory(uint64(m.Quantity))
	}
	if m.EntityID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.EntityID))
	}
	if m.TransactionTypeID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.TransactionTypeID))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovPlayerInventory(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovPlayerInventory(uint64(l))
	}
	return n
}

func (m *GetPlayerResourcesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	return n
}

func (m *GetPlayerResourcesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for _, e := range m.PlayerInventory {
			l = e.Size()
			n += 1 + l + sovPlayerInventory(uint64(l))
		}
	}
	return n
}

func (m *GetPlayerResourcesByCategoryIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	if m.ResourceCategoryID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.ResourceCategoryID))
	}
	return n
}

func (m *GetPlayerResourcesByCategoryIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for _, e := range m.PlayerInventory {
			l = e.Size()
			n += 1 + l + sovPlayerInventory(uint64(l))
		}
	}
	return n
}

func (m *GetPlayerItemsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	return n
}

func (m *GetPlayerItemsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for _, e := range m.PlayerInventory {
			l = e.Size()
			n += 1 + l + sovPlayerInventory(uint64(l))
		}
	}
	return n
}

func (m *GetPlayerAmuletsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	return n
}

func (m *GetPlayerAmuletsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerInventory != nil {
		l = m.PlayerInventory.Size()
		n += 1 + l + sovPlayerInventory(uint64(l))
	}
	return n
}

func (m *GetPlayerItemByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	if m.ItemID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.ItemID))
	}
	return n
}

func (m *GetPlayerItemByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerInventory != nil {
		l = m.PlayerInventory.Size()
		n += 1 + l + sovPlayerInventory(uint64(l))
	}
	return n
}

func (m *GetPlayerResourceByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	if m.ResourceID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.ResourceID))
	}
	return n
}

func (m *GetPlayerResourceByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerInventory != nil {
		l = m.PlayerInventory.Size()
		n += 1 + l + sovPlayerInventory(uint64(l))
	}
	return n
}

func (m *GetPlayerPacksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	return n
}

func (m *GetPlayerPacksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerInventory) > 0 {
		for _, e := range m.PlayerInventory {
			l = e.Size()
			n += 1 + l + sovPlayerInventory(uint64(l))
		}
	}
	return n
}

func (m *DepositResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.ResourceID))
	}
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	if m.Quantity != 0 {
		n += 1 + sovPlayerInventory(uint64(m.Quantity))
	}
	return n
}

func (m *DepositResourceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WithdrawResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.ResourceID))
	}
	if m.PlayerID != 0 {
		n += 1 + sovPlayerInventory(uint64(m.PlayerID))
	}
	if m.Quantity != 0 {
		n += 1 + sovPlayerInventory(uint64(m.Quantity))
	}
	return n
}

func (m *WithdrawResourceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPlayerInventory(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlayerInventory(x uint64) (n int) {
	return sovPlayerInventory(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlayerInventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerInventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerInventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			m.EntityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionTypeID", wireType)
			}
			m.TransactionTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionTypeID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &Resource{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &Item{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerResourcesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerResourcesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerResourcesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerResourcesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerResourcesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerResourcesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerInventory = append(m.PlayerInventory, &PlayerInventory{})
			if err := m.PlayerInventory[len(m.PlayerInventory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerResourcesByCategoryIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerResourcesByCategoryIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerResourcesByCategoryIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCategoryID", wireType)
			}
			m.ResourceCategoryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceCategoryID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerResourcesByCategoryIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerResourcesByCategoryIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerResourcesByCategoryIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerInventory = append(m.PlayerInventory, &PlayerInventory{})
			if err := m.PlayerInventory[len(m.PlayerInventory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerItemsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerItemsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerItemsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerItemsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerItemsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerItemsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerInventory = append(m.PlayerInventory, &PlayerInventory{})
			if err := m.PlayerInventory[len(m.PlayerInventory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerAmuletsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerAmuletsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerAmuletsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerAmuletsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerAmuletsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerAmuletsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerInventory == nil {
				m.PlayerInventory = &PlayerInventory{}
			}
			if err := m.PlayerInventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerItemByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerItemByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerItemByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerItemByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerItemByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerItemByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerInventory == nil {
				m.PlayerInventory = &PlayerInventory{}
			}
			if err := m.PlayerInventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerResourceByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerResourceByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerResourceByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerResourceByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerResourceByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerResourceByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerInventory == nil {
				m.PlayerInventory = &PlayerInventory{}
			}
			if err := m.PlayerInventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerPacksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerPacksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerPacksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPlayerPacksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerPacksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerPacksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerInventory = append(m.PlayerInventory, &PlayerInventory{})
			if err := m.PlayerInventory[len(m.PlayerInventory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositResourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositResourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositResourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawResourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawResourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawResourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayerInventory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlayerInventory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlayerInventory(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlayerInventory
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayerInventory
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlayerInventory
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlayerInventory
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlayerInventory
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlayerInventory        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlayerInventory          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlayerInventory = fmt.Errorf("proto: unexpected end of group")
)
